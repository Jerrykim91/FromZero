<br>

#### 3. 파이썬 심화 - 클로저(Closure)


내용이 어려워서 정리 필요 

<br>

# 클로저(Closure) 

```py
# 함수안에 함수를 만들어서 지역변수 호출 

def Func():              # 1. 선언 
    Code = 'Func의 test' # 3. 변수 선언

    def FuncInFunc():
        print(Code)      # 4. Code변수를 참고하여 출력 
                         # 6. 이 함수에서 정의 되지 않았지만 사용됨  -> Func안에 들어있는 모든 코드에 접근가능함
        
    return FuncInFunc()  # 5. 호출과 동시에 리턴 -> return 생략가능

Func()                   # 2. 실행

# Output
# >>>> Func의 test

```

일반 함수와는 다르게 자신의 영역 밖에서 호출된 함수의 변수 값과 레퍼런스를 복사하고 저장한뒤 값들을 엑세스 가능하게 해주는 역활을 한다. 

- 어떤 함수를 함수 자신이 가지고 있는 환경과 함께 저장한 레코드 이며 
    - 코드안에 정의 되지 않은 변수를 클로저가 만들어지는 당시의 값과 레퍼런스에 맵핑하여 주는 역할을 한다. 


- 함수를 둘러싼 환경을 유지하다가, 함수를 호출 할때 다시 꺼내서 사용하는 함수를 클로저라고 한다. 

<br>
<br>

## 클로저(Closure) 사용하기 

<br>

- 함수 내부에서 정의된 함수는 클로저 될 수 있다.
- 클로저는 바깥 함수로부터 생성된 변수값을 변경 또는 저장할 수 있는 함수

<br>
<br>

### 함수를 클로저 형태로 만드는 방법

<br>
함수 바깥쪽에 있는 지역변수를 사용해서 연산을 진행     

글로저를 사용하면 프로그램의 흐름을 변수에 저장가능     
클로저 = 지역변수 + 코드 묶어서 사용

클로저에 속한 지역변수는 바깥에서 직접 접근 할 수 없으므로 데이터를 숨기고 싶을때 사용    

<br>

```py
## 클로저 형태의 함수 

def closr():                # 1. 선언 
    i = 10
    j = 10

    def mul(x):             # 4. 호출
        return i * x + j    # 5. 함수 밖의 변수 호출해서 연산 후 리턴  

    return mul              # 3. mul 함수를 리턴 
                            # 함수를 리턴 할때는 함수 이름만 반환 -> ()는 사용하면 x 


y = closr()                 # 2. 호출 
                            # y에 저장된 함수 => 클로저

print(y(1),y(2),y(3),y(4),y(5))

# Output
# >>> 20 30 40 50 60 

dum = [ y(i) for i in range(1,6)]
print(dum) 

# Output
# >>> [20, 30, 40, 50, 60]
```

<br>

###  클로저 만들기 - lambda 사용
<br>

람다 표현식을 이용하면 클로저를 쉽게 만들 수 있다.     
클로저와 람다표현식은 주로 같이 사용하는 경우가 많아서 혼동하기가 쉬운데

- 람다
    - 이름 없는 익명함수
- 클로저
    - 함수를 툴러싼 환경을 유지하고 니후에 다시 사용하는 함수

두 함수는 다르다. 그렇기 때문에 혼동하지 말자.  

<br>

```py
# lambda 사용 

def closr():                
    i = 10
    j = 10

    return lambda x: i * x + j  # 람다 표현식을 반환 

y = closr() 
print(y(1),y(2),y(3),y(4),y(5))

# Output
# >>> [20, 30, 40, 50, 60]

```

<br>

## 클로저 응용 

앞에서 배운 변수들을 이용해서 클로저의 지역 변수를 변경해보자.

```py

def closr():                
    i = 10
    j = 10
    tal = 0

    def mul(x):   
        nonlocal tal  # 
        tal = tal + i * x + j     # 값이 누적   
        print(tal)  
    return mul

y = closr() 

print(y(1),y(2),y(3))

# Output
# >>> 20
# >>> 50
# >>> 90
# >>> None None None  # print()문 때문에 생성 

y(1)
y(2)
y(3)

# Output
# >>> 20
# >>> 50
# >>> 90
```


<br>
<br>

## Reference <br>

- 파이썬 코딩도장 &nbsp; : &nbsp;<https://dojang.io/> <br>
- SchoolOfWeb &nbsp; : &nbsp;  <http://schoolofweb.net/> <br>


